import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// Get authentication headers
function getAuthInfo(request: Request): { userEmail: string | null, userId: string | null } {
  const userEmail = request.headers.get('x-user-email');
  const userId = request.headers.get('x-user-id');
  return { userEmail, userId };
}

// Get or create a default conversation for AI-generated concepts
async function getOrCreateDefaultConversation(userId: string, userEmail: string): Promise<string> {
  try {
    // Look for an existing "AI Generated Concepts" conversation
    let conversation = await prisma.conversation.findFirst({
      where: {
        userId: userId,
        title: "AI Generated Concepts"
      }
    });

    if (!conversation) {
      // Create a new conversation for AI-generated concepts
      conversation = await prisma.conversation.create({
        data: {
          title: "AI Generated Concepts",
          summary: "Collection of concepts generated by AI suggestions",
          text: "This conversation contains concepts that were generated automatically by AI suggestions.",
          userId: userId,
          createdAt: new Date()
        }
      });
    }

    return conversation.id;
  } catch (error) {
    console.error('Error getting/creating default conversation:', error);
    throw new Error('Failed to create conversation for concept');
  }
}

// Enhanced LeetCode problem detection (shared with other routes)
function detectLeetCodeProblem(conversationText: string): { isLeetCode: boolean, problemName?: string, approach?: string } {
  const text = conversationText.toLowerCase();
  
  // Common LeetCode problem patterns
  const leetcodePatterns = [
    { pattern: /contains?\s+duplicate/i, name: "Contains Duplicate" },
    { pattern: /valid\s+anagram/i, name: "Valid Anagram" },
    { pattern: /two\s+sum/i, name: "Two Sum" },
    { pattern: /three\s+sum/i, name: "Three Sum" },
    { pattern: /reverse\s+linked\s+list/i, name: "Reverse Linked List" },
    { pattern: /merge\s+(?:two\s+)?sorted\s+(?:arrays?|lists?)/i, name: "Merge Two Sorted Lists" },
    { pattern: /palindrome\s+(?:string|number|linked\s+list)/i, name: "Valid Palindrome" },
    // Add more patterns as needed
  ];
  
  // Check for exact LeetCode problem matches
  for (const { pattern, name } of leetcodePatterns) {
    if (pattern.test(text)) {
      return { isLeetCode: true, problemName: name };
    }
  }
  
  // Check for general problem indicators
  const problemIndicators = [
    "leetcode", "algorithm problem", "coding problem", "interview question"
  ];
  
  const isLeetCodeStyle = problemIndicators.some(indicator => text.includes(indicator));
  return { isLeetCode: isLeetCodeStyle };
}

// Generate enhanced guidance for the backend
function generateLeetCodeGuidance(conversationText: string) {
  const detection = detectLeetCodeProblem(conversationText);
  
  if (!detection.isLeetCode) {
    return null;
  }
  
  let guidance = `This is about a LeetCode-style algorithm problem. When generating the concept title, use the EXACT problem name if known (e.g., "Contains Duplicate", "Valid Anagram", "Two Sum", etc.). Focus on the specific problem, not just the technique used.`;

  if (detection.problemName) {
    guidance += ` Detected Problem: "${detection.problemName}" - use this as the title.`;
  }
  
  return guidance;
}

export async function POST(request: Request) {
  try {
    const { conceptName, context, sourceConcept } = await request.json();
    const { userEmail, userId } = getAuthInfo(request);

    if (!conceptName || typeof conceptName !== 'string') {
      return NextResponse.json({ 
        success: false, 
        error: 'Concept name is required' 
      }, { status: 400 });
    }

    // Verify authentication for database operations
    if (!userEmail || !userId) {
      return NextResponse.json({
        success: false,
        error: 'Authentication required'
      }, { status: 401 });
    }

    // Create a prompt specifically for generating concept details from just a name
    let generationPrompt = context 
      ? `Based on this conversation context:\n\n${context}\n\nPlease provide a comprehensive technical explanation of the concept: "${conceptName}".`
      : `Please provide a comprehensive technical explanation of the concept: "${conceptName}".`;

    // If we have source concept info, add it to the context for relationship establishment
    if (sourceConcept) {
      generationPrompt += `\n\nThis concept should relate to "${sourceConcept.title}" in the "${sourceConcept.category}" category. Make sure to explain how "${conceptName}" connects to or builds upon "${sourceConcept.title}".`;
    }

    // Detect LeetCode problems and generate guidance
    const fullContext = context ? `${context} ${conceptName}` : conceptName;
    const leetcodeGuidance = generateLeetCodeGuidance(fullContext);

    // Use the existing Python backend service to generate the concept
    const httpsUrl = process.env.BACKEND_URL || 'https://recall.p3vg.onrender.com';
    const httpUrl = httpsUrl.replace('https://', 'http://');
    
    let backendResponse;
    try {
      console.log("Attempting HTTPS connection for concept generation...");
      backendResponse = await fetch(`${httpsUrl}/api/v1/extract-concepts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          conversation_text: generationPrompt + 
            ` Include a detailed summary, key points, implementation details, code examples if applicable, ` +
            `related concepts, and appropriate categorization. Focus specifically on "${conceptName}" as the main concept.`,
          context: null,
          category_guidance: leetcodeGuidance ? { guidance: leetcodeGuidance } : null
        }),
      });
    } catch (sslError) {
      console.log("HTTPS failed for concept generation, trying HTTP fallback...", sslError instanceof Error ? sslError.message : 'SSL connection failed');
      backendResponse = await fetch(`${httpUrl}/api/v1/extract-concepts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          conversation_text: generationPrompt + 
            ` Include a detailed summary, key points, implementation details, code examples if applicable, ` +
            `related concepts, and appropriate categorization. Focus specifically on "${conceptName}" as the main concept.`,
          context: null,
          category_guidance: leetcodeGuidance ? { guidance: leetcodeGuidance } : null
        }),
      });
    }

    if (!backendResponse.ok) {
      throw new Error(`Backend service failed: ${backendResponse.status}`);
    }

    const backendData = await backendResponse.json();
    
    // Find the most relevant concept from the backend response
    let generatedConcept = null;
    if (backendData.concepts && backendData.concepts.length > 0) {
      // Look for a concept that matches the requested name most closely
      generatedConcept = backendData.concepts.find((concept: any) => 
        concept.title.toLowerCase().includes(conceptName.toLowerCase()) ||
        conceptName.toLowerCase().includes(concept.title.toLowerCase())
      ) || backendData.concepts[0]; // Fallback to first concept if no close match
    }

    if (!generatedConcept) {
      return NextResponse.json({
        success: false,
        error: 'Failed to generate concept content'
      }, { status: 500 });
    }

    // Now save the generated concept to the database
    try {
      // Use the AI-generated category, not the source concept's category
      // This allows the new concept to have its own appropriate category
      const conceptCategory = generatedConcept.category || 'General';
      
      const savedConcept = await prisma.concept.create({
        data: {
          title: generatedConcept.title,
          category: conceptCategory, // Use AI-generated category
          summary: generatedConcept.summary || '',
          details: generatedConcept.details || generatedConcept.implementation || '',
          keyPoints: JSON.stringify(generatedConcept.keyPoints || []),
          examples: JSON.stringify(generatedConcept.examples || []),
          relatedConcepts: JSON.stringify(generatedConcept.relatedConcepts || []),
          relationships: generatedConcept.relationships ? JSON.stringify(generatedConcept.relationships) : '{}',
          confidenceScore: 0.8, // Higher confidence for explicitly requested concepts
          userId: userId,
          lastUpdated: new Date(),
          // We need a conversationId - use a default or create a placeholder conversation
          conversationId: sourceConcept?.conversationId || await getOrCreateDefaultConversation(userId, userEmail),
        }
      });

      // Create code snippets if any were generated
      if (generatedConcept.codeSnippets && generatedConcept.codeSnippets.length > 0) {
        await Promise.all(
          generatedConcept.codeSnippets.map((snippet: any) => 
            prisma.codeSnippet.create({
              data: {
                conceptId: savedConcept.id,
                language: snippet.language || 'javascript',
                description: snippet.description || 'Generated example',
                code: snippet.code || ''
              }
            })
          )
        );
      }

      // IMPORTANT: If this was generated from a connection dialog, establish the relationship
      if (sourceConcept && sourceConcept.id) {
        try {
          console.log(`🔗 Establishing relationship between source concept ${sourceConcept.id} and generated concept ${savedConcept.id}`);
          
          // Get the source concept's current relationships
          const sourceConceptData = await prisma.concept.findUnique({
            where: { id: sourceConcept.id },
            select: { relatedConcepts: true, title: true }
          });
          
          if (sourceConceptData) {
            // Parse existing relationships
            let existingRelatedConcepts = [];
            try {
              existingRelatedConcepts = JSON.parse(sourceConceptData.relatedConcepts || '[]');
              if (!Array.isArray(existingRelatedConcepts)) existingRelatedConcepts = [];
            } catch {
              existingRelatedConcepts = [];
            }
            
            // Add the new generated concept to source concept's relationships
            const newRelationship = { id: savedConcept.id, title: savedConcept.title };
            const relationshipExists = existingRelatedConcepts.some((rel: any) => 
              (typeof rel === 'object' && rel.id === savedConcept.id) ||
              (typeof rel === 'string' && rel === savedConcept.title)
            );
            
            if (!relationshipExists) {
              existingRelatedConcepts.push(newRelationship);
              
              // Update source concept
              await prisma.concept.update({
                where: { id: sourceConcept.id },
                data: { relatedConcepts: JSON.stringify(existingRelatedConcepts) }
              });
            }
            
            // Add reverse relationship - source concept to generated concept
            const reverseRelationship = { id: sourceConcept.id, title: sourceConceptData.title };
            let generatedConceptRelated = [];
            try {
              generatedConceptRelated = JSON.parse(savedConcept.relatedConcepts || '[]');
              if (!Array.isArray(generatedConceptRelated)) generatedConceptRelated = [];
            } catch {
              generatedConceptRelated = [];
            }
            
            const reverseExists = generatedConceptRelated.some((rel: any) => 
              (typeof rel === 'object' && rel.id === sourceConcept.id) ||
              (typeof rel === 'string' && rel === sourceConceptData.title)
            );
            
            if (!reverseExists) {
              generatedConceptRelated.push(reverseRelationship);
              
              // Update generated concept
              await prisma.concept.update({
                where: { id: savedConcept.id },
                data: { relatedConcepts: JSON.stringify(generatedConceptRelated) }
              });
            }
            
            console.log(`✅ Successfully established bidirectional relationship between "${sourceConceptData.title}" and "${savedConcept.title}"`);
          }
        } catch (relationshipError) {
          console.error('❌ Error establishing concept relationship:', relationshipError);
          // Don't fail the whole operation if relationship creation fails
        }
      }

      console.log(`✅ Successfully created AI-generated concept: "${savedConcept.title}" (ID: ${savedConcept.id})`);

      // Return the saved concept with the real database ID
      return NextResponse.json({
        success: true,
        concept: {
          id: savedConcept.id,
          title: savedConcept.title,
          category: savedConcept.category,
          summary: savedConcept.summary,
          details: savedConcept.details,
          keyPoints: savedConcept.keyPoints,
          examples: savedConcept.examples,
          relatedConcepts: savedConcept.relatedConcepts,
          relationships: savedConcept.relationships,
          confidenceScore: savedConcept.confidenceScore,
          createdAt: savedConcept.createdAt,
          lastUpdated: savedConcept.lastUpdated
        }
      });

    } catch (dbError) {
      console.error('Database error while saving generated concept:', dbError);
      return NextResponse.json({
        success: false,
        error: 'Failed to save generated concept to database'
      }, { status: 500 });
    }

  } catch (error) {
    console.error('Error generating concept:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'An unexpected error occurred'
    }, { status: 500 });
  }
} 